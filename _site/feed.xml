<?xml version="1.0" encoding="UTF-8"?> <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel><title>游戏暂停</title><description>李家伟的博客。</description><link>http://lijiawei.cc</link><atom:link href="http://lijiawei.cc/feed.xml" rel="self" type="application/rss+xml" /> <item><title>MIT 计算机科学导论结课小结</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#python-抽象分解&quot; id=&quot;markdown-toc-python-抽象分解&quot;&gt;Python 抽象分解&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#对象和类型&quot; id=&quot;markdown-toc-对象和类型&quot;&gt;对象和类型&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#变量&quot; id=&quot;markdown-toc-变量&quot;&gt;变量&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#数据结构&quot; id=&quot;markdown-toc-数据结构&quot;&gt;数据结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#函数&quot; id=&quot;markdown-toc-函数&quot;&gt;函数&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#生成器&quot; id=&quot;markdown-toc-生成器&quot;&gt;生成器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#类&quot; id=&quot;markdown-toc-类&quot;&gt;类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#递归&quot; id=&quot;markdown-toc-递归&quot;&gt;递归&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#错误处理&quot; id=&quot;markdown-toc-错误处理&quot;&gt;错误处理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#算法&quot; id=&quot;markdown-toc-算法&quot;&gt;算法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;今天完成了 MITx: 6.00.1x Introduction to Computer Science and Programming Using Python，是这个暑假「完成」的第一门 MOOC，给「完成」加了引号，是因为是跳过了 Problem Set，我当然知道练习很重要，但对于基础的 Python 编程作业实在上不了心，用时30小时，11天，中间有几天偷懒，有两天做 BearCity 3 的中文字幕，所以说，这个速度我可相当满意了。&lt;/p&gt; &lt;p&gt;上这门课的原因也很简单，我意识到对 Python 的理解有短板，为什么要 OOP？Python 中 method 和 function 有何区别？怎么写？上完课后，这些问题也得到了解答。&lt;/p&gt; &lt;p&gt;课程我给 4.5/5，课程内容、视频制作剪辑、课后资料都完美，每一段视频的时间很短，10分钟左右，并且都配有课后练习。最不满的就是 edX 的证书有时间规定的，我上课的时候已经不能领证书，也就作罢。&lt;/p&gt; &lt;p&gt;回想起今年寒假，我看了几节生成器（generator）和递归的内容，看得头晕目眩眼花缭乱，这次老老实实从头开始上，很顺利地掌握了。我可以清晰地看到自己在 11 天里的进步，因此我也推荐给任何有一定基础的初学者。&lt;/p&gt; &lt;p&gt;为什么说要有一定基础？因为我大一的时候上过几节，讲得太过深入，什么是机器？什么是算法？图灵机解决的可计算性问题是什么？听不懂，因为这门课不仅教你编程，还教你什么是计算思维（computational thinking）。这门课也很「枯燥」，他假定了你对计算机足够有兴趣了。如果把这门课和 CS50 比，就是天差地别：CS50 讲课注重趣味性，然后你发现老师满头大汗讲了一个半小时就为了演示编码的意义；6.00.1x 讲究知识面和思维训练，把每个坑和用法演示得清清楚楚，还有海量的作业让你慢慢领悟。我写的 &lt;a href=&quot;http://lijiawei.cc/2017/07/24/float/&quot;&gt;十进制与二进制：为什么浮点数不准？&lt;/a&gt; 就是从 6.00.1x 里学来的，6.00.1x 用10分钟的视频讲完了原理和演示，CS 50 花了半个小时。&lt;/p&gt; &lt;p&gt;这门课的核心是计算思维，计算思维听起来很玄乎，但就是程序员最擅长的那一套：抽象分解、自动化、算法。把一个大问题层层剥离，选择合适的算法，编写合适的程序，逐个击破，最终解决问题。我把这门课的内容分成 Python 抽象分解、递归、错误处理、算法这四个部分，随便聊聊。&lt;/p&gt; &lt;h2 id=&quot;python-抽象分解&quot;&gt;Python 抽象分解&lt;/h2&gt; &lt;h3 id=&quot;对象和类型&quot;&gt;对象和类型&lt;/h3&gt; &lt;p&gt;Everything in Python is an object. 所有能被程序操作的东西，都叫对象。每个对象都有一个类型（type），类型决定了这个对象可以做什么，Python 中的类型包括 int、float、string、list 等等。&lt;/p&gt; &lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt; &lt;p&gt;变量是最简单的抽象，用变量名指代一个变量，你就不用管这个变量怎么实现的。&lt;/p&gt; &lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt; &lt;p&gt;把数据比作水，数据结构就是杯子，我们需要不同的数据结构来装数据。Python 中的数据结构包括 tuple、list、dictionary。这里比较 tricky 的部分是 list 和 dictionary 是可变的，当我们让多个变量指向同一个 list 或者 dictionary 的时候，任何一个变量变化，其他变量也会变化。演示如下：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;a = [1, 2, 4] b = a a[0] = 0 print(b) # [0, 2, 4] &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;所以，在复制 list 或者 dictionary 的时，务必使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;b = a[:]&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;c = aDict.copy()&lt;/code&gt;。&lt;/p&gt; &lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt; &lt;p&gt;函数把一系列动作抽象，这样就不用老是复制同样的代码，把这一系列动作抽象，我不需要关心代码如何实现，以后只要用这个函数就可以了。值得一提的是，在 Python 中，函数也是个对象，你可以把函数名作为参数传递到另一个函数里。演示如下：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def sampleF(x): return x ** 2 def Y(f, a): return f(a) aInt = 9 Y(sampleF, aInt) &lt;/code&gt;&lt;/pre&gt; &lt;h3 id=&quot;生成器&quot;&gt;生成器&lt;/h3&gt; &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;range()&lt;/code&gt; 就是个生成器，当我们用 &lt;code class=&quot;highlighter-rouge&quot;&gt;for i in range(1000)&lt;/code&gt; 的时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;range()&lt;/code&gt; 不是一下子就生成了1000个整数，而是每次要用到的时候，生成1个整数，下次用到的时候，再生成一个，以节省内存开支。&lt;/p&gt; &lt;p&gt;把函数里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; 换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 即可创造一个生成器。&lt;/p&gt; &lt;h3 id=&quot;类&quot;&gt;类&lt;/h3&gt; &lt;p&gt;如果我们需要抽象一套新的数据结构（你也可以理解为定义新的类型），就需要用到类（class）。类定义了这个数据结构里有哪些 attribute，有哪些 method，怎么 print，怎么加减乘除，怎么比较大小。类可以继承，把父类的 attribute 和 method 继承的子类里。&lt;/p&gt; &lt;h2 id=&quot;递归&quot;&gt;递归&lt;/h2&gt; &lt;p&gt;递归把一个大问题分解成一个小问题，把小问题解决，就把大问题解决了，一个例子就是&lt;a href=&quot;http://lijiawei.cc/2017/07/25/hanoi/&quot;&gt;汉诺塔问题&lt;/a&gt;。递归的理论基础是数学归纳法，如果函数在 n 的条件下成立可以推导出在 n+1 的条件下也成立，这时候只要证明 n = 1 时函数成立，就能证明 n &amp;gt; 1 的情况下也成立。归纳法是个在数学证明里非常有用的方法，这里不展开了。&lt;/p&gt; &lt;h2 id=&quot;错误处理&quot;&gt;错误处理&lt;/h2&gt; &lt;p&gt;有时候程序会出错，这里有两个思路：一个是如果出错了，那我执行这么一段代码，也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;try: except: else: finally: &lt;/code&gt;；另一个思路是如果出错了，就报错，有两个方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;raise&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;。&lt;/p&gt; &lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt; &lt;p&gt;算法就是给计算机解决问题的一套指令，这里我想说一下怎么比较算法的好坏。计算机理论用大 O 记号表示算法的复杂度，即算法在最坏情况下所需操作步数随输入增长的情况，如果是线性增长，则为 O(n)，如果是 log 增长，例如二分法，就计为 O(log n)。&lt;/p&gt; </description><pubDate>Wed, 02 Aug 2017 15:10:00 +0100</pubDate><link>http://lijiawei.cc/posts/mitx6001/</link><guid isPermaLink="true">http://lijiawei.cc/posts/mitx6001/</guid> </item> <item><title>用递归解汉诺塔问题</title><description>&lt;p&gt;这里我默认读者具有基本的递归知识。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;汉诺塔是根据一个传说形成的数学问题：&lt;br /&gt; 有三根杆子A，B，C。A杆上有N个(N&amp;gt;1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：&lt;br /&gt; 每次只能移动一个圆盘；&lt;br /&gt; 大盘不能叠在小盘上面。&lt;br /&gt; 提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。&lt;br /&gt; 问：如何移？&lt;/p&gt; &lt;p&gt;来源：&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/汉诺塔&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;3Blue1Brown 在 YouTube 上有个&lt;a href=&quot;https://www.youtube.com/watch?v=2SUvWfNJSsM&amp;amp;feature=youtu.be&quot;&gt;精彩的视频&lt;/a&gt;用动画讨论了这个问题，以及二进制计数解法，可以去瞧一瞧。本文主要探讨递归解法，该解法在&lt;a href=&quot;https://www.zhihu.com/question/24385418&quot;&gt;知乎&lt;/a&gt;上也有很高质量的讨论。&lt;/p&gt; &lt;p&gt;这个问题初看很难用代码实现，但通过仔细观察（其实就是看解答啦），可以发现：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;如果我们适当地忽略一些规则，允许几个盘可以一起移动，可以把 A 杆上的圆盘 N 分成两部分，最底层的 1 个圆盘 bottom 和上面的 N-1 个圆盘堆 top。&lt;/li&gt; &lt;li&gt;我们把 top 移到 B 杆（中转站），bottom 移到 C 杆（目的地），再把 top 移到 C 杆（目的地），即可解决问题。&lt;/li&gt; &lt;li&gt;再抽象一下，对于有&lt;strong&gt;两部分&lt;/strong&gt;的圆盘堆移动到目的地，需要三个步骤： &lt;ol&gt; &lt;li&gt;top：起始地 -&amp;gt; 中转站&lt;/li&gt; &lt;li&gt;bottom：起始地 -&amp;gt; 目的地（此时的 bottom 是大盘，故不影响其他的盘的移动）&lt;/li&gt; &lt;li&gt;top：中转站 -&amp;gt; 目的地&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;此时我们就可以给出这个递归的解法了。我们先定义一个函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;move(origin, destination)&lt;/code&gt;帮我们打印出步骤，接受两个参数原位置和目标位置。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def move(origin, destination): ''' origin, destination: str Print out movement from origin to destination ''' print('Move from %s to %s.' % (origin, destination)) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;现在定义解决问题的函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;hanoiTowerSolver(n, fr, to, spare)&lt;/code&gt;，接受四个参数，盘数（N），起始地（A），目的地（C），中转站（B）。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def hanoiTowerSolver(n, fr, to, spare): ''' n: int fr: str, the starting rod to: str, the destination rod spare: str, the rod other than 'fr' and 'to' Print out how to move n disks from the starting rod to the the destination rod. ''' &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;这个函数达到最小规模 N = 1 的时候，我只要从起始地（fr）移到目的地（to）就好了。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def hanoiTowerSolver(n, fr, to, spare): ''' n: int fr: str, the starting rod to: str, the destination rod spare: str, the rod other than 'fr' and 'to' Print out how to move n disks from the starting rod to the the destination rod. ''' if n == 1: move(fr, to) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;如果 N 不是 1，那么就意味着要移动&lt;strong&gt;有两部分的圆盘堆&lt;/strong&gt;，上文提到：&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;……对于有&lt;strong&gt;两部分&lt;/strong&gt;的圆盘堆移动到目的地，需要三个步骤：&lt;br /&gt; top（N-1）：起始地 -&amp;gt; 中转站&lt;br /&gt; bottom（1）：起始地 -&amp;gt; 目的地&lt;br /&gt; top（N-1）：中转站 -&amp;gt; 目的地&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;把这些步骤转换成代码，如下。&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def hanoiTowerSolver(n, fr, to, spare): ''' n: int fr: str, the starting rod to: str, the destination rod spare: str, the rod other than 'fr' and 'to' Print out how to move n disks from the starting rod to the the destination rod. ''' if n == 1: move(fr, to) else: hanoiTowerSolver(n-1, fr, spare, to) hanoiTowerSolver(1, fr, to, spare) hanoiTowerSolver(n-1, spare, to, fr) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;n = 5，测试结果如下：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Move from A to B. Move from A to C. Move from B to C. Move from A to B. Move from C to A. Move from C to B. Move from A to B. Move from A to C. Move from B to C. Move from B to A. Move from C to A. Move from B to C. Move from A to B. Move from A to C. Move from B to C. Move from A to B. Move from C to A. Move from C to B. Move from A to B. Move from C to A. Move from B to C. Move from B to A. Move from C to A. Move from C to B. Move from A to B. Move from A to C. Move from B to C. Move from A to B. Move from C to A. Move from C to B. Move from A to B. &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;源代码位于&lt;a href=&quot;https://github.com/iewaij/introductionToComputerScience/blob/master/hanoiTowerSolver.py&quot;&gt;我的 GitHub 仓库&lt;/a&gt;中。&lt;/p&gt; </description><pubDate>Tue, 25 Jul 2017 15:10:00 +0100</pubDate><link>http://lijiawei.cc/posts/hanoi/</link><guid isPermaLink="true">http://lijiawei.cc/posts/hanoi/</guid> </item> <item><title>十进制与二进制：为什么浮点数不准？</title><description>&lt;p&gt;写代码的时候经常会发现计算机应该返回0.3，返回的却是0.30000011241，这是因为二进制转换为十进制时可能会有偏差。&lt;/p&gt; &lt;p&gt;计算机是用开关的开和闭来表示1和0，因此计算机只能「计算」二进制。关于这部分更详细的介绍，例如图灵机、逻辑电路等内容，可以看&lt;a href=&quot;https://www.amazon.cn/Code-The-Hidden-Language-of-Computer-Hardware-and-Software-Petzold-Charles/dp/0735611319/ref=sr_1_5?ie=UTF8&amp;amp;qid=1500874764&amp;amp;sr=8-5&amp;amp;keywords=%E7%BC%96%E7%A0%81+%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80&quot;&gt;《编码:隐匿在计算机软硬件背后的语言》&lt;/a&gt;一书，也可以看李戈老师精彩的公开课&lt;a href=&quot;https://pan.baidu.com/share/link?uk=1846002289&amp;amp;shareid=1862561932#list/path=%2F&quot;&gt;《计算概论 A》&lt;/a&gt;的前三节，&lt;a href=&quot;https://cs50.harvard.edu/&quot;&gt;CS50&lt;/a&gt; 有更简短的介绍，本文的截图就来自 CS50。&lt;/p&gt; &lt;p&gt;与计算机不同，人类是用十进制思考的，十进制，顾名思义，每到十就进一位，我们从0数到9，然后十位进一位得1，各位变成0，也就是10。&lt;/p&gt; &lt;p&gt;这里我有个不太理解的地方，从直觉的角度，人有十根手指头，应当从「一根」数到「十根」，每一根手指都应当有标准的符号，为什么第十根就变成10了呢？汉字用「一二三四五六七八九十」反而更自然吧。这里我没有更深入的查证，可能是因为古埃及和古巴比伦很早就有了高级的数字表示法，有兴趣的可以一起讨论。&lt;/p&gt; &lt;p&gt;十进制下，145这样的数字，代表 1 × 100 + 4 × 10 + 5 × 1。二进制下，1011 代表 1 × 8 + 0 × 4 + 1 × 2 + 1 × 1。&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fhux3pnyu4j31ao0k0jsu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fhux3oatd3j31ao0k0jtc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;十进制如何转换成二进制呢？一种思路是想成搭积木，如何用1、2、4、8、16……这些2的幂指数组合成十进制的数。比如42这个数，这是个偶数，所以我不用1，我肯定要用上32，然后我再找到2和8就够了，4和16都不要，所以二进制是101010。另一种思路是用算法，42 ÷ 2 取余数 0 得 21，21 ÷ 2 取余数 1 得 10，10 ÷ 2 取余数 0 得 5，5 ÷ 2 取余数 1 得 2，2 ÷ 2 取余数 0 得 1，1 ÷ 2 取余数 1 得 0。把这些余数从后到前，101010 即为二进制转换的结果。&lt;/p&gt; &lt;p&gt;本质上，第一种方法和第二种方法是相同的，通过余数判断这个数有没有1，再判断有没有2、4、8…… 如果有余数，就代表取1，没有就代表取0。&lt;/p&gt; &lt;p&gt;如果这个数有小数部分，就有点棘手了，以 1.25 为例，我先要让这个数变成整数，先乘上 2^3，1.25 × 2^3 = 10。十进制的10转换成二进制是1010，因为我之前已经让这个数乘上 2^3 次方了，所以我要除掉 2^3，在十进制里，我们除1000就是退三位，比如2274 ÷ 1000 = 2.274，在二进制里，除 2^3 就是退三位，1010 退三位是 1.010 也就是 1.01。&lt;/p&gt; &lt;p&gt;在转换的时候，我们会要求计算机把这个小数不断地 × 2，直到变成整数，但有些数字，比如 0.225，不论你乘上多少2的倍数，都没法变成整数，于是计算机只能近似地用二进制表示这些数，计算完毕后再转换成十进制出现在你的屏幕上，这个转换必然是有误差的，这就是出现 0.30000011241 这样的浮点数的原因。&lt;/p&gt; &lt;p&gt;所以在写代码的时候，a 和 b 分别是两个浮点数，不要出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;if a == b&lt;/code&gt;这样的判断，因为 a 和 b 经过计算后会有偏差，应该写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;if a - b &amp;lt;= 0.00001&lt;/code&gt;。&lt;/p&gt; </description><pubDate>Mon, 24 Jul 2017 13:40:00 +0100</pubDate><link>http://lijiawei.cc/posts/float/</link><guid isPermaLink="true">http://lijiawei.cc/posts/float/</guid> </item> <item><title>机器如何判断句子的情绪？</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#以后的文章就用-latex-写公式啦&quot; id=&quot;markdown-toc-以后的文章就用-latex-写公式啦&quot;&gt;以后的文章就用 LaTex 写公式啦&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;博文内容和 Markdown 语法有冲突，请移步至我的 &lt;a href=&quot;https://github.com/iewaij/machine-learning-lab/blob/master/Naive_Bayes/note/Naive_Emo_Bayes_Notes.ipynb&quot;&gt;GitHub 笔记&lt;/a&gt;和&lt;a href=&quot;https://github.com/iewaij/machine-learning-lab/blob/master/Naive_Bayes/code/Naive_Emo_Bayes.ipynb&quot;&gt;代码&lt;/a&gt;，多谢包涵！&lt;/p&gt; &lt;h2 id=&quot;以后的文章就用-latex-写公式啦&quot;&gt;以后的文章就用 LaTex 写公式啦&lt;/h2&gt; &lt;p&gt;用 MathJax 渲染，效果如下：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$$E=mc^2$$ is a inline formula &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;E=mc^2&lt;/script&gt; is a inline formula&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-LaTex&quot;&gt;$$e^x=\sum_{i=0}^\infty \frac{1}{i!}x^i$$ &lt;/code&gt;&lt;/pre&gt; &lt;script type=&quot;math/tex; mode=display&quot;&gt;e^x=\sum_{i=0}^\infty \frac{1}{i!}x^i&lt;/script&gt; </description><pubDate>Mon, 20 Mar 2017 01:18:00 +0000</pubDate><link>http://lijiawei.cc/posts/naive-emo-bayes/</link><guid isPermaLink="true">http://lijiawei.cc/posts/naive-emo-bayes/</guid> </item> <item><title>使用概率让机器学会语言生成</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#句子的概率&quot; id=&quot;markdown-toc-句子的概率&quot;&gt;句子的概率&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#蒙特卡洛方法&quot; id=&quot;markdown-toc-蒙特卡洛方法&quot;&gt;蒙特卡洛方法&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#马尔科夫假设与-n-gram-模型&quot; id=&quot;markdown-toc-马尔科夫假设与-n-gram-模型&quot;&gt;马尔科夫假设与 N-gram 模型&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#collections-与-random-模块用法&quot; id=&quot;markdown-toc-collections-与-random-模块用法&quot;&gt;collections 与 random 模块用法&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#counter&quot; id=&quot;markdown-toc-counter&quot;&gt;Counter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#defaultdict&quot; id=&quot;markdown-toc-defaultdict&quot;&gt;defaultdict&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#random&quot; id=&quot;markdown-toc-random&quot;&gt;random&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#python-实现&quot; id=&quot;markdown-toc-python-实现&quot;&gt;Python 实现&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#概率计算&quot; id=&quot;markdown-toc-概率计算&quot;&gt;概率计算&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#句子生成&quot; id=&quot;markdown-toc-句子生成&quot;&gt;句子生成&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;句子的概率&quot;&gt;句子的概率&lt;/h2&gt; &lt;p&gt;句子对不对和语法语义都无关，而是和句子出现的概率有关。&lt;/p&gt; &lt;h2 id=&quot;蒙特卡洛方法&quot;&gt;蒙特卡洛方法&lt;/h2&gt; &lt;p&gt;生成随机数，概率越大的越容易被随机数「抽」到。&lt;/p&gt; &lt;h2 id=&quot;马尔科夫假设与-n-gram-模型&quot;&gt;马尔科夫假设与 N-gram 模型&lt;/h2&gt; &lt;p&gt;用条件概率推测词的概率。&lt;/p&gt; &lt;h2 id=&quot;collections-与-random-模块用法&quot;&gt;collections 与 random 模块用法&lt;/h2&gt; &lt;h3 id=&quot;counter&quot;&gt;Counter&lt;/h3&gt; &lt;p&gt;计数。&lt;/p&gt; &lt;h3 id=&quot;defaultdict&quot;&gt;defaultdict&lt;/h3&gt; &lt;p&gt;如果 key 不存在，自动生成 key。&lt;/p&gt; &lt;h3 id=&quot;random&quot;&gt;random&lt;/h3&gt; &lt;p&gt;抛出随机数。&lt;/p&gt; &lt;h2 id=&quot;python-实现&quot;&gt;Python 实现&lt;/h2&gt; &lt;h3 id=&quot;概率计算&quot;&gt;概率计算&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;使用结巴分词配合 defaultdict() 得到 key 为条件，value 为词 list 的词典。&lt;/li&gt; &lt;/ul&gt; &lt;h3 id=&quot;句子生成&quot;&gt;句子生成&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;w1, w2 可人工填入，或者用随机方法生成。&lt;/li&gt; &lt;li&gt;在 w1, w2 的条件下，在字典里查找 key 为 w1, w2 的情况，用 randomint () 抽出 w3。&lt;/li&gt; &lt;li&gt;在 w2, w3 的条件下，生成 w4。&lt;/li&gt; &lt;li&gt;……&lt;/li&gt; &lt;/ul&gt; </description><pubDate>Tue, 14 Mar 2017 01:49:00 +0000</pubDate><link>http://lijiawei.cc/posts/N-gram/</link><guid isPermaLink="true">http://lijiawei.cc/posts/N-gram/</guid> </item> <item><title>Docker + TensorFlow 入门</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#镜像和容器&quot; id=&quot;markdown-toc-镜像和容器&quot;&gt;镜像和容器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#上手&quot; id=&quot;markdown-toc-上手&quot;&gt;上手&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#homebrew-安装-docker&quot; id=&quot;markdown-toc-homebrew-安装-docker&quot;&gt;Homebrew 安装 Docker&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#docker-加速器设置&quot; id=&quot;markdown-toc-docker-加速器设置&quot;&gt;Docker 加速器设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#tensorflow-镜像安装&quot; id=&quot;markdown-toc-tensorflow-镜像安装&quot;&gt;TensorFlow 镜像安装&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#docker-关键命令&quot; id=&quot;markdown-toc-docker-关键命令&quot;&gt;Docker 关键命令&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#让容器与本机的文件夹同步&quot; id=&quot;markdown-toc-让容器与本机的文件夹同步&quot;&gt;让容器与本机的文件夹同步&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#jupyter-notebook-主题更改&quot; id=&quot;markdown-toc-jupyter-notebook-主题更改&quot;&gt;Jupyter Notebook 主题更改&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Docker 是个非常轻量级的虚拟机，可以保证环境不影响代码的运行。&lt;/p&gt; &lt;p&gt;TensorFlow 官方在 Docker 上有镜像，可以直接下载。这几天研究了一点 Docker，感觉只看懂了一小角，也不知道对不对，就斗胆先写一些了。&lt;/p&gt; &lt;h2 id=&quot;镜像和容器&quot;&gt;镜像和容器&lt;/h2&gt; &lt;p&gt;Docker Hub 上可以得到各种来源的镜像，这个镜像就像以前装系统的光盘或者 .iso，装载了这个系统最初始的状态。&lt;/p&gt; &lt;p&gt;Docker 可以帮助我们把这个镜像安装，变成我们可以使用的容器，在这个容器里随便折腾，折腾完了可以删掉，再从镜像新建一个新容器，这样可以保证以前的折腾不会影响现在的代码，队友的环境也可以和自己保持一致。&lt;/p&gt; &lt;h2 id=&quot;上手&quot;&gt;上手&lt;/h2&gt; &lt;p&gt;本文以 Mac 为例，介绍如何上手 Docker。&lt;/p&gt; &lt;h3 id=&quot;homebrew-安装-docker&quot;&gt;Homebrew 安装 Docker&lt;/h3&gt; &lt;p&gt;如果有 homebrew，直接运行代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask install docker&lt;/code&gt; 即可安装 Docker，启动 Docker 后，Menu Bar 上会出现一只鲸鱼，也不是很明白鲸鱼和虚拟机有什么关系。&lt;/p&gt; &lt;h3 id=&quot;docker-加速器设置&quot;&gt;Docker 加速器设置&lt;/h3&gt; &lt;p&gt;因为国内的垃圾网络，最好装加速器来减少下载镜像的等待时间，我用了号称永久免费的 &lt;a href=&quot;https://www.daocloud.io/&quot;&gt;DaoCloud&lt;/a&gt;，在得到镜像地址后，在 Docker 中如图所示设置。&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;http://lijiawei.cc/images/屏幕快照 2017-03-05 下午2.57.26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;h3 id=&quot;tensorflow-镜像安装&quot;&gt;TensorFlow 镜像安装&lt;/h3&gt; &lt;p&gt;启动 Docker，然后终端运行以下命令，即可从 Docker Hub 上下载 TensorFlow 镜像。&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it -p 8888:8888 tensorflow/tensorflow &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;如果你想要和你的容器共享文件，那么最好用这个命令：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it -p 8888:8888 -v ~/pathe/to/folder/you/wannna/share:/portal tensorflow/tensorflow &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;从你的容器访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/portal&lt;/code&gt; 文件夹，就是你电脑上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/pathe/to/folder/you/wannna/share&lt;/code&gt; 文件夹。&lt;code class=&quot;highlighter-rouge&quot;&gt;/portal&lt;/code&gt; 这个名字可以随便改，不过我觉得叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;/portal&lt;/code&gt; 还蛮酷的。&lt;/p&gt; &lt;p&gt;如果一切顺利的话，你就可以打开终端的链接，从浏览器访问 Jupyter Notebook 了。&lt;/p&gt; &lt;h3 id=&quot;docker-关键命令&quot;&gt;Docker 关键命令&lt;/h3&gt; &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker images&lt;/code&gt; 查看装了哪些镜像：&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;http://lijiawei.cc/images/屏幕快照 2017-03-05 下午3.05.15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker rmi &amp;lt;image name or tag or ID whatever&amp;gt;&lt;/code&gt; 可以删除镜像。&lt;/p&gt; &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt; 查看正在运行的容器（图中没有正在运行的容器）：&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;http://lijiawei.cc/images/屏幕快照 2017-03-05 下午3.07.15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt; 查看所有的容器：&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;http://lijiawei.cc/images/屏幕快照 2017-03-05 下午3.08.37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker rm &amp;lt;container name or tag or ID whatever&amp;gt;&lt;/code&gt; 可以删除容器。&lt;/p&gt; &lt;p&gt;如果觉得一个一个删太烦，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker rm $(docker ps -a -q)&lt;/code&gt;删除所有容器。&lt;/p&gt; &lt;p&gt;若要停止容器（比如端口被占），运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker stop &amp;lt;container name or tag or ID whatever&amp;gt;&lt;/code&gt;。启动容器运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker start &amp;lt;container name or tag or ID whatever&amp;gt;&lt;/code&gt;。&lt;/p&gt; &lt;p&gt;好的，现在到关键部分了！当我创建了一个 TensorFlow 容器后，我该怎么开始运行 Jupyter Notebook 呢？运行&lt;code class=&quot;highlighter-rouge&quot;&gt;docker start -i &amp;lt;container name or tag or ID whatever&amp;gt;&lt;/code&gt; 就可以了！&lt;/p&gt; &lt;p&gt;在 notebook 里测试一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;/portal&lt;/code&gt; 是否正常，可以运行：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!ls /portal/ &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;如果你和一样用的是 oh-my-zsh，你可以在 zshconfig 里加上这两个 alias 方便以后使用：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 新建容器并从 /portal 传输文件 alias tfdocker=&quot;docker run -it -p 8888:8888 -v ~/Coding/DeepLearning101:/portal tensorflow/tensorflow&quot; # 启动 ID 为 a4032edb39cb 的容器并开启 Jupyter Notebook alias startdocker=&quot;docker start -i a4032edb39cb&quot; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;h1 id=&quot;让容器与本机的文件夹同步&quot;&gt;让容器与本机的文件夹同步&lt;/h1&gt; &lt;p&gt;参考&lt;a href=&quot;https://github.com/junjielizero/DeepLearning101/blob/master/ch0/note/README.md&quot;&gt;junjielizero 的笔记&lt;/a&gt;，运行下列命令，可以创建于本机文件夹同步的笔记。&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it -p 8888:8888 -v ~/Coding/DeepLearning101:/Coding/DeepLearning101 -w /Coding/DeepLearning101 tensorflow/tensorflow &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;h2 id=&quot;jupyter-notebook-主题更改&quot;&gt;Jupyter Notebook 主题更改&lt;/h2&gt; &lt;p&gt;用了新编辑器怎么可以不换主题，在 Jupyter Notebook 中，以感叹号开头运行命令就是终端指令。在 notebook 中运行：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!pip install --upgrade jupyterthemes &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;如果一切顺利（在中国的垃圾网络下怎么可能顺利，你可能要多试几次），你就可以参考&lt;a href=&quot;https://github.com/dunovank/jupyter-themes&quot;&gt;GitHub - dunovank/jupyter-themes 文档&lt;/a&gt; 做主题调整了。我输入的命令是：&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 用 solarized-light 主题，代码字体是 inputmono，字号 12 点，界面字体 sourcesans，输出字体 sourcesans，开启工具栏，开启标题栏 !jt -t solarized-light -f inputmono -fs 12 -nf sourcesans -tf sourcesans -T -N &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;结果如图：&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tKfTcgy1fdc04dobmyj30se0oyaec.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; </description><pubDate>Sun, 05 Mar 2017 15:32:00 +0000</pubDate><link>http://lijiawei.cc/posts/Docker-TensorFlow/</link><guid isPermaLink="true">http://lijiawei.cc/posts/Docker-TensorFlow/</guid> </item> <item><title>用树莓派实现 HomeKit 控制台灯</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#配置树莓派&quot; id=&quot;markdown-toc-配置树莓派&quot;&gt;配置树莓派&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#更换国内镜像源&quot; id=&quot;markdown-toc-更换国内镜像源&quot;&gt;更换国内镜像源&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#安装-nodejs-及相关依赖&quot; id=&quot;markdown-toc-安装-nodejs-及相关依赖&quot;&gt;安装 Node.js 及相关依赖&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#安装-homebridge-及相关依赖&quot; id=&quot;markdown-toc-安装-homebridge-及相关依赖&quot;&gt;安装 homebridge 及相关依赖&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#安装-homebridge-yeelight&quot; id=&quot;markdown-toc-安装-homebridge-yeelight&quot;&gt;安装 homebridge-yeelight&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#开机启动&quot; id=&quot;markdown-toc-开机启动&quot;&gt;开机启动&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;在看到少数派上的 &lt;a href=&quot;http://sspai.com/36617&quot;&gt;借助树莓派与 HomeBridge ，将 YeeLight 彩光灯接入 Apple HomeKit&lt;/a&gt; 一文后, 非常心动. 在暑假的时候关注过一阵子 yeelight, 那时实现的功能非常有限还不支持 IFTTT 就作罢没有买, 但到了12月后, yeelight 既有 IFTTT 又能玩 homekit, 于是立马下单了树莓派 3 和 yeelight.&lt;/p&gt; &lt;p&gt;树莓派可以理解为一台微型电脑 (开发板), 运行的是树莓派定制的 Rapbian, 虽然树莓派并不是性能最强也不是最有性价比的开发板, 但它的社区支持是最友好的 (毕竟面向的人群还包括儿童), 它出的杂志 MagPi 极度令人沉迷 (甚至能让我回忆起从前看大众软件的时光), 官方的教程和文档对新手非常友好 (只需要一点点英语基础就够), 作为对比让我们斜眼一下 &lt;a href=&quot;https://developer.qualcomm.com/hardware/dragonboard-410c/tutorial-videos&quot;&gt;DragonBoard 410c&lt;/a&gt;, 任何出现的问题只要 Google 一下 Raspberry Pi + 关键词都能找到, 其配套的硬件软件也很出色, 例如 sense hat 可以直接配合自带的 sense hat emulator. 因此非常推荐任何对编程感兴趣的人入手.&lt;/p&gt; &lt;p&gt;本文用到的硬件如下:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;宜家 E27 螺孔台灯 RMB 99&lt;/li&gt; &lt;li&gt;yeelight 彩光版 RMB 89&lt;/li&gt; &lt;li&gt;树莓派 3 Model B (同时配了外壳和散热片) RMB 206&lt;/li&gt; &lt;li&gt;预先烧录好 NOOBS 的 Micro SD 卡&lt;/li&gt; &lt;li&gt;网线&lt;/li&gt; &lt;li&gt;有线鼠标&lt;/li&gt; &lt;li&gt;戴尔显示器&lt;/li&gt; &lt;li&gt;Macbook Pro&lt;/li&gt; &lt;li&gt;iPhone&lt;/li&gt; &lt;/ol&gt; &lt;h2 id=&quot;配置树莓派&quot;&gt;配置树莓派&lt;/h2&gt; &lt;p&gt;参考官方指南 &lt;a href=&quot;https://www.raspberrypi.org/learning/software-guide/&quot;&gt;Raspberry Pi Software Guide&lt;/a&gt; 烧录 Micro SD 卡. 把下载好的 &lt;a href=&quot;https://www.raspberrypi.org/downloads/noobs/&quot;&gt;NOOBS for Raspberry Pi&lt;/a&gt; 解压缩然后拷到 SD 卡上. 当然, 也可以直接烧录 Raspbian 到 SD 卡, 这样就不用忍受 NOOBS 安装的漫长时间, 直接插卡就能开机.&lt;/p&gt; &lt;p&gt;插入有线鼠标 (带 USB 发射埠的无线鼠标也可以, 凑活用就好, 之后可以在 Macbook 上使用 SSH 操作), Micro SD 卡, HDMI 线, 网线, Micro USB 电源, 然后就可以安装 Raspbian, 安装完毕后就能进入系统.&lt;/p&gt; &lt;p&gt;进入系统后, 点击左上角 Preferences - Raspberry Pi Configuration, 打开 SSH 和 VNC. 建议在这里顺便更改用户密码.&lt;/p&gt; &lt;p&gt;这时候就可以切回 Macbook, 打开终端 (我使用的是 iTerm2), 输入代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh pi@raspberrypi.local&lt;/code&gt; 然后输入树莓派的密码, 连接树莓派.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79gw1fbg76r9rl7j30oa0g1mzm.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;更具体的操作方法, 请参考官方帮助页面 &lt;a href=&quot;https://www.raspberrypi.org/learning/software-guide/&quot;&gt;Raspberry Pi Software Guide&lt;/a&gt;.&lt;/p&gt; &lt;h2 id=&quot;更换国内镜像源&quot;&gt;更换国内镜像源&lt;/h2&gt; &lt;p&gt;由于国内访问树莓派服务器的不便, 因此需要更换为国内镜像, 这里我将 sources 的镜像更换为速度更快的阿里云, archive.raspberrypi.org 的镜像只找到中科大的, 因此使用了中科大的镜像.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/apt/sources.list # 用 # 注释掉原有的 source, 输入阿里云镜像. deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006tNc79gw1fbg76t6uh7j30oa0g142p.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;更换中科大镜像的方法一样, 但文件位置及名字不同.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/apt/sources.list.d/raspi.list # 注释掉原来的, 输入中科大镜像 deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ jessie main ui &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79gw1fbg76rmtg6j30oa0g1jtv.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;更换好源后, 输入以下代码就可以不用忍受龟速更新系统了.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update sudo apt-get upgrade &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;h2 id=&quot;安装-nodejs-及相关依赖&quot;&gt;安装 Node.js 及相关依赖&lt;/h2&gt; &lt;p&gt;Homebridge 是一个用 node.js 开发的 HomeKit 服务器, 因此需要参考 &lt;a href=&quot;https://github.com/nfarina/homebridge/wiki/Running-HomeBridge-on-a-Raspberry-Pi&quot;&gt;Running HomeBridge on a Raspberry Pi&lt;/a&gt; 在树莓派上先安装 node.js, 由于国内网络问题, 仍然需要更换镜像.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash - # 更换为国内源 sudo nano /etc/apt/sources.list.d/nodesource.list # 输入清华大学镜像 deb http://mirrors.tuna.tsinghua.edu.cn/nodesource/deb/ jessie main deb-src http://mirrors.tuna.tsinghua.edu.cn/nodesource/deb/ jessie main &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;这时候就可以安装 node.js 以及其相关依赖了.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install -y nodejs sudo apt-get install libavahi-compat-libdnssd-dev &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;h2 id=&quot;安装-homebridge-及相关依赖&quot;&gt;安装 homebridge 及相关依赖&lt;/h2&gt; &lt;p&gt;Homebridge 属于 node.js 下的模块之一, 这时候需要用到 npm 安装, npm 的速度也是很令人着急, 但好在 npm 可以使用代理, 这里我们使用淘宝镜像下载 homebridge. 本步骤比较繁琐, 依旧参考 &lt;a href=&quot;https://github.com/nfarina/homebridge/wiki/Running-HomeBridge-on-a-Raspberry-Pi&quot;&gt;Running HomeBridge on a Raspberry Pi&lt;/a&gt;.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在命令后添加 --registry=http://r.cnpmjs.org 使用国内 npm 镜像代理 sudo npm install -g --unsafe-perm homebridge hap-nodejs node-gyp --registry=http://r.cnpmjs.org cd /usr/lib/node_modules/homebridge/ sudo npm install --unsafe-perm bignum --registry=http://r.cnpmjs.org cd /usr/lib/node_modules/hap-nodejs/node_modules/mdns sudo node-gyp BUILDTYPE=Release rebuild &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;这时候可以输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;homebridge&lt;/code&gt; 测试能否正常运行 homebridge, 如果一切顺利的话, 能看到 homebridge 一直运行且没有报错, 打开手机的家庭 app 添加配件就能看到 homebridge.&lt;/p&gt; &lt;h2 id=&quot;安装-homebridge-yeelight&quot;&gt;安装 homebridge-yeelight&lt;/h2&gt; &lt;p&gt;记得打开 yeelight 的极客模式, 最新版本 (0.0.1.4) 的 &lt;a href=&quot;https://www.npmjs.com/package/homebridge-yeelight&quot;&gt;homebridge-yeelight&lt;/a&gt; 已经不需要更改 config.json 了, 因此直接输入以下代码就完成了配置, 能在手机里添加台灯了.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo npm install -g homebridge-yeelight --registry=http://r.cnpmjs.org homebridge &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;h2 id=&quot;开机启动&quot;&gt;开机启动&lt;/h2&gt; &lt;p&gt;&lt;a href=&quot;https://github.com/nfarina/homebridge/wiki/Running-HomeBridge-on-a-Raspberry-Pi&quot;&gt;Running HomeBridge on a Raspberry Pi&lt;/a&gt; 上给出的添加启动项实在是太繁琐了, 我甚至因为这一步没弄明白重新刷了次机, 还顺便搞懂了.bashrc 和 rc.local 有什么区别. 事实上, 树莓派文档 &lt;a href=&quot;https://www.raspberrypi.org/documentation/linux/usage/cron.md&quot;&gt;Scheduling tasks with Cron&lt;/a&gt; 给出的方法是最简单且方便以后配置别的程序的.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 先安装 cron sudo apt-get install gnome-schedule &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;然后配置 cron.&lt;/p&gt; &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;crontab -e &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;在最下方添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@reboot homebridge &amp;amp;&lt;/code&gt; 即可完成开机启动 homebridge 的配置. 再多嘴一句, cron 这个命令非常好用, 在 system tools 里有 GUI 界面, 还能让树莓派完成每周日运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get update sudo apt-get update&lt;/code&gt; 这样的定时任务.&lt;/p&gt; &lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt; &lt;p&gt;&lt;a href=&quot;https://www.raspberrypi.org/documentation/linux/usage/cron.md&quot;&gt;Scheduling tasks with Cron - Raspberry Pi Documentation (树莓派官方的资料真的非常友好)&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://www.raspberrypi.org/documentation/&quot;&gt;Raspberry Pi Documentation&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://sspai.com/36617&quot;&gt;借助树莓派与HomeBridge，将 YeeLight 彩光灯接入 Apple HomeKit - 少数派&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://bbs.xiaomi.cn/t-13198850&quot;&gt;小米网关接入Homekit完整教程，声控家中设备! - 小米社区官方论坛&lt;/a&gt;&lt;/p&gt; </description><pubDate>Fri, 06 Jan 2017 00:08:00 +0000</pubDate><link>http://lijiawei.cc/rpi-homekit-yeelight.html</link><guid isPermaLink="true">http://lijiawei.cc/rpi-homekit-yeelight.html</guid> </item> <item><title>我2016年的习得与利器</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#碎片知识&quot; id=&quot;markdown-toc-碎片知识&quot;&gt;碎片知识&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#学习&quot; id=&quot;markdown-toc-学习&quot;&gt;学习&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#娱乐&quot; id=&quot;markdown-toc-娱乐&quot;&gt;娱乐&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#电影&quot; id=&quot;markdown-toc-电影&quot;&gt;电影&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#音乐&quot; id=&quot;markdown-toc-音乐&quot;&gt;音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#游戏&quot; id=&quot;markdown-toc-游戏&quot;&gt;游戏&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#知识文献管理&quot; id=&quot;markdown-toc-知识文献管理&quot;&gt;知识（文献）管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#写作&quot; id=&quot;markdown-toc-写作&quot;&gt;写作&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#发布&quot; id=&quot;markdown-toc-发布&quot;&gt;发布&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;碎片知识&quot;&gt;碎片知识&lt;/h2&gt; &lt;p&gt;改掉了用稍后读（Pocket）然后再也不读的习惯，先大量读并注意用非常快速地方式标记（例如知乎的点赞），然后用6小时回顾法和卡片法增加记忆难度。&lt;/p&gt; &lt;p&gt;关于6小时回顾法和卡片法，请参考&lt;a href=&quot;http://www.yangzhiping.com/psy/live002.yangtalk.html&quot;&gt;读书十二问&lt;/a&gt;。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/&quot;&gt;知乎&lt;/a&gt; 依然是我知识输入的主力。&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://sspai.com/&quot;&gt;少数派&lt;/a&gt; 依然是我 Mac 和 iOS 上工具使用的输入主力。&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://liqi.io/&quot;&gt;利器&lt;/a&gt;通过采访各领域的创造者并获知他（她）们背后的工具，是我今年剁手的主要来源。&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://the-offline.com/&quot;&gt;OFFLINE&lt;/a&gt;，性感的科技文化网站。&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.yangzhiping.com/&quot;&gt;阳志平的博客&lt;/a&gt; 对我彻底打开了认知科学的大门，之前在 Coursera 的对认知科学的学习仍然是一知半解，但 &lt;a href=&quot;http://www.yangzhiping.com/&quot;&gt;阳志平的博客&lt;/a&gt; 的介绍极接地气和系统。&lt;/li&gt; &lt;li&gt;Reeder 用于 RSS 订阅。 &lt;img src=&quot;http://ww3.sinaimg.cn/large/006y8lVagw1faq83vgtnej31hc0u00yg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt; &lt;li&gt;PDF Expert 用于 PDF 批注。&lt;/li&gt; &lt;li&gt;Alfred 用于搜索、启动应用和一些简单脚本，例如开启 Aria2、查找豆瓣评分、知乎搜索。&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;学习&quot;&gt;学习&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://coursera.com/&quot;&gt;Coursera&lt;/a&gt;， &lt;a href=&quot;https://classroom.udacity.com/me&quot;&gt;Udacity&lt;/a&gt; 和 &lt;a href=&quot;https://courses.edx.org/dashboard&quot;&gt;edX&lt;/a&gt; 是我系统学习输入的主力，暑假拿了两张证书，完成了 Python 和单变量微积分的学习，接触了很多经济学、认知科学、计算机科学的知识&lt;del&gt;（然而并没有完成）&lt;/del&gt;。&lt;/li&gt; &lt;li&gt;Kindle 依然占我阅读的大头，依然觉得自己一无所知，今年包了 Kindle Unlimited。我喜欢把 Kindle 用于&lt;strong&gt;不需要精读&lt;/strong&gt;的内容，今年非虚构类主要大量接触了创业、产品管理、项目管理、自我驱动、设计、哲学方面的知识，虚构类最爱的是火星救援、月亮和六便士、人间失格。&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;娱乐&quot;&gt;娱乐&lt;/h2&gt; &lt;h3 id=&quot;电影&quot;&gt;电影&lt;/h3&gt; &lt;p&gt;你的名字、神奇动物在哪里、比利林恩的中场战事、独立游戏大电影、路边野餐是我 2016 年 TOP 5。&lt;/p&gt; &lt;p&gt;二刷的有你的名字、美人鱼、功夫熊猫3（春节实在太无聊了)。&lt;/p&gt; &lt;p&gt;今年还去了上海电影节，塔科夫斯基的电影实在太难看懂了。&lt;/p&gt; &lt;h3 id=&quot;音乐&quot;&gt;音乐&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;口味基本没怎么变，今年最爱的乐队是 Chinese Football 和草东没有派对。&lt;/li&gt; &lt;li&gt;两场音乐节南京森林和宁波草莓，三场 Livehouse，大波浪、MONO、肆囍。下一次 Livehouse 就是明年的大象体操了。&lt;/li&gt; &lt;/ul&gt; &lt;h3 id=&quot;游戏&quot;&gt;游戏&lt;/h3&gt; &lt;p&gt;没时间打游戏了，今年通了神秘海域4，半途而废的有 Braid、Inside以及其他好多没印象的。&lt;/p&gt; &lt;h2 id=&quot;知识文献管理&quot;&gt;知识（文献）管理&lt;/h2&gt; &lt;p&gt;要用的知识太多，随手收藏的知识容易忘，放文件夹里缺少标签和标记，word 里插 citation 是车祸现场，所以今年开始使用知识和文献管理。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Endnote，因为学校电脑里有 Endnote，所以写论文时的文献管理的主力还是 Endnote，我把 Endnote Library 放到学校邮箱的 OneDrive 上，基本上在机房写作的工作流就是登录 Chrome、登录邮箱、打开 Endnote、开始写作。&lt;/li&gt; &lt;li&gt;Zotero，我的主力知识管理软件，Endnote 太大了，还收费，我的 Zotero 用于保存我会时不时查找和翻阅的知识，如图所示，效果拔群。 &lt;img src=&quot;http://ww1.sinaimg.cn/large/006y8lVagw1faq82jb1caj31hc0u0dm3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://trello.com&quot;&gt;Trello&lt;/a&gt;，项目管理、项目 wiki 都放 Trello 上，太好用了，人类的希望。 &lt;img src=&quot;http://ww4.sinaimg.cn/large/006y8lVagw1faq7eby84tj31hc0u013w.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;写作&quot;&gt;写作&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.bear-writer.com/&quot;&gt;Bear (Notes for iPhone, iPad and Mac)&lt;/a&gt;，我尝试过无数的写作工具，包括 Ulysses，Mou，Typora 等等等，在今年大部分时间我都是使用 Dayone 2 写作，直到我用了 Bear。写作工具这东西确实比较私人，我是觉得一定要不断地找才能找的到。&lt;/li&gt; &lt;li&gt;Trello，卡片式写作。&lt;/li&gt; &lt;li&gt;石墨文档，用于团队文档的协作。&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;发布&quot;&gt;发布&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;对朋友圈有洁癖，不想打扰人，所以朋友圈只发真正有价值的东西。&lt;/li&gt; &lt;li&gt;学了 Python，然后用 Python、Pelican、腾讯云服务器搭了自己的博客（博客才让自己有地主的感觉）。&lt;/li&gt; &lt;/ul&gt; </description><pubDate>Wed, 14 Dec 2016 12:41:00 +0000</pubDate><link>http://lijiawei.cc/posts/my-2016/</link><guid isPermaLink="true">http://lijiawei.cc/posts/my-2016/</guid> </item> <item><title>卡片式写作</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#我为何写此文&quot; id=&quot;markdown-toc-我为何写此文&quot;&gt;我为何写此文？&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#基本流程&quot; id=&quot;markdown-toc-基本流程&quot;&gt;基本流程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#卡片信息化&quot; id=&quot;markdown-toc-卡片信息化&quot;&gt;卡片信息化&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#工具与环境&quot; id=&quot;markdown-toc-工具与环境&quot;&gt;工具与环境&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#信息化流程&quot; id=&quot;markdown-toc-信息化流程&quot;&gt;信息化流程&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#背后原理组块化&quot; id=&quot;markdown-toc-背后原理组块化&quot;&gt;背后原理：组块化&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#必要难度&quot; id=&quot;markdown-toc-必要难度&quot;&gt;必要难度&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#抽象层级分解&quot; id=&quot;markdown-toc-抽象层级分解&quot;&gt;抽象层级分解&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#卡片式写作的缺点&quot; id=&quot;markdown-toc-卡片式写作的缺点&quot;&gt;卡片式写作的缺点&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;我为何写此文&quot;&gt;我为何写此文？&lt;/h2&gt; &lt;p&gt;纳博科夫，一位科学家、文学家、极客，他创造的独特的卡片式写作法，用卡片的形式代替传统的一本道写作，我在第一次接触后大为震撼，此文章就是我第一次使用卡片式写作法写就，耗时 4 小时左右，从来没感觉写作可以这么酣畅淋漓。下图就是我使用写作软件的截图。&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006y8lVagw1faqnc4mfp7j31hc0u07el.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;卡片式写作法概况起来有以下好处：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;资料收集，帮助记忆。&lt;/li&gt; &lt;li&gt;快速写作，构思先行。&lt;/li&gt; &lt;li&gt;减少畏惧，力注卡片。&lt;/li&gt; &lt;li&gt;远距联想，卡片交互，新思迸发。&lt;/li&gt; &lt;li&gt;组块思维，理顺逻辑。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;在此文中，我主要查阅了一下两篇文章，此文算是笔记加上我自己的补充，我强烈推荐各位读读这两篇原文：&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://site.douban.com/210084/widget/notes/13276908/note/488643066/&quot;&gt;阳志平 - 纳博科夫的卡片&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://www.cnfeat.com/blog/2016/11/20/NabokovWriteStyle/&quot;&gt;像纳博科夫一样写作：卡片创作法&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;基本流程&quot;&gt;基本流程&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;准备好卡片创作工具&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;可以去淘宝上买索引纸和铅笔，但对我来说，电脑是最好的写作工具，我会再补充我如何使用电子设备进行卡片式写作。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;撰写大纲&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;作品的构思先于作品本身。就像玩字谜游戏，我随意在空白处填写。我在卡片上写下这些段落，直到完成整部小说。——纳博科夫&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;卡片可分为两种，大纲卡和拓展卡。卡片创作的第一步就是创作大纲卡，在写大纲卡时，思考以下这三个问题：为什么要写?读者是谁？预期结果是什么？&lt;/p&gt; &lt;ul&gt; &lt;li&gt;拓展要点&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;注意在拓展卡中使用湿货。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;编辑成文&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;拓展卡完成后，再将各个拓展卡拼接起来，纯拼接不难，拼接得好看就需要能力，这种拼接的能力就是远距联想能力。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;检查修改&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;卡片信息化&quot;&gt;卡片信息化&lt;/h2&gt; &lt;p&gt;我不是特别喜欢纸笔，易丢，不好保存，不方便更改，20世纪的纳博科夫是使用索引卡和铅笔撰写作品的，而我目前正在探索我的卡片式写作的信息化流程。&lt;/p&gt; &lt;h3 id=&quot;工具与环境&quot;&gt;工具与环境&lt;/h3&gt; &lt;p&gt;目前我使用的写作工具和环境如下：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;写作软件，Bear。出色的设计和跨平台性能，虽然目前有几点小瑕疵，但已经能很好地达到我的要求。&lt;/li&gt; &lt;li&gt;写作软件，Trello。Trello 既是一个项目协作软件，也是个出色的卡片面板，虽然现在的写作主力不是 Trello，但 Trello 面板更容易让我看到全局，这是 Bear 比不上的。&lt;/li&gt; &lt;li&gt;知识管理软件，Zotero。收集资料里能浏览器里一键放入资料库，我在收集、阅读一部分资料后也会在 Zotero 中写一句话总结。&lt;/li&gt; &lt;li&gt;写作硬件，Macbook Pro+外接显示器+蓝牙键盘+ iPhone。Macbook Pro 是我的写作主力，即便现在 iOS 的生产力已经不错，但电脑的大屏幕依然给我相当的安全感，iPhone 的便携性可以帮助我捕捉灵感，随时写一点东西。&lt;/li&gt; &lt;li&gt;大部分时间，我都在宿舍里写作。&lt;/li&gt; &lt;/ul&gt; &lt;h3 id=&quot;信息化流程&quot;&gt;信息化流程&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;浏览资料，有时候该步骤可以跳过。主要是通过互联网，比较好的资料就收藏进 Zotero 中。&lt;/li&gt; &lt;li&gt;有大致概念后，开始撰写大纲（大纲卡）。&lt;/li&gt; &lt;li&gt;按照大纲，在 Bear 中创建含标题的笔记（拓展卡），并打上标签，方便识别层级顺序。&lt;/li&gt; &lt;li&gt;不断捕捉灵感，在写作时总是发现大纲中可能没有的东西，这些灵感会继续转换成新的笔记或者是一篇新文章。&lt;/li&gt; &lt;li&gt;拓展卡基本写满后，寻找各个笔记间的联系，并通过 Bear 的跳转功能插入到笔记中。&lt;/li&gt; &lt;li&gt;整理，修改，发布。&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;背后原理组块化&quot;&gt;背后原理：组块化&lt;/h2&gt; &lt;p&gt;当我们只看一个概念时，我们肯定是毫无头绪的，但是当我们专注地（而不是发散地）把相关的概念一一梳理，把所有概念整理成一个整体，也即是组块时，我们的大脑会更加适应也更容易处理。卡片式写作恰好顺应了这个过程。&lt;/p&gt; &lt;h3 id=&quot;必要难度&quot;&gt;必要难度&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;人们常通常认为，记得越快，就是学习效果越好。简而言之，存储越容易，提取就会越快。但是近些年，最新实验发现了与常识相反的结论：存储与提取负相关。&lt;/p&gt; &lt;p&gt;也就是说，存入记忆容易，提取出来会不容易；反之，如果你有些吃力地存入，那么，提取会更牢。比如，我们的常识是要在课堂上记笔记。但是必要难度原理建议，别在课堂上记笔记，老师边讲边记笔记，你会听得太明白，写入太容易，但是大脑那块硬盘未来会不易提取出来。过些日子，多数遗忘。反之，如果我们略微增加一下写入难度，比如晚上回到宿舍或者第二天再写笔记，这样未来提取会更容易。也就是，你有些困难地存入，会记得更好并真正学会。——阳志平&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;必要难度可以视作组块理论的记忆运用，当我们使用容易的方式记忆时（分神、多任务等等），我们获得的概念并没有被大脑专注地处理，也因此无法形成相应的组块。相比于拍照、复制粘贴，卡片式写作要求我们用更大的难度收集、记录资料，这会使我们更容易记忆。阳志平的原文里给出了钱鐘书的例子，值得一看。&lt;/p&gt; &lt;h3 id=&quot;抽象层级分解&quot;&gt;抽象层级分解&lt;/h3&gt; &lt;p&gt;根据组块理论，我们的大脑更喜欢「把一些有关联的东西加以分类或加工使之成为一个组块」，因此我们做任务、解决问题时倾向于把任务、问题层层分解，使之变成一个个空白的组块再向这些组块里填充内容。我们的大脑也更适应处理同一抽象层级的事情，即写大纲时专注于文章构思，写拓展时更关注于某一张卡片上的内容。卡片式做法顺应了这方法，当我们把注意力集中在一张张卡片上时，干扰因素更少，更专注于填充该卡片的组块，并且创意密度会更大。我个人经验里，卡片式写作减少了我的写作恐惧，我更愿意舒舒服服地写几百字，而不是一下子就写满几页，并且当我看到我已经写了这么多字的时候，我会自我安慰「看我都写了这么多字了，应该差不多了吧」。&lt;/p&gt; &lt;h1 id=&quot;卡片式写作的缺点&quot;&gt;卡片式写作的缺点&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;组块与组块之间的联系不够，需要后期润色加工。&lt;/li&gt; &lt;li&gt;需要极强的联想能力，为什么这个卡片可以和那个卡片联系？然而思考这个问题的时候，作者处于极度疲惫的状态。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;我认为卡片式写作应该多放几天再发布，因为不是一本道式酣畅淋漓地写就，因此修改需要大量的时间。&lt;/p&gt; &lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;https://site.douban.com/210084/widget/notes/13276908/note/488643066/&quot;&gt;阳志平 - 纳博科夫的卡片&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://www.cnfeat.com/blog/2016/11/20/NabokovWriteStyle/&quot;&gt;陈素封 - 像纳博科夫一样写作：卡片创作法&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19879632&quot;&gt;采铜 - 思维运筹学导论（实践篇 · 组块化 · 上） - 开放的智力&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19882157&quot;&gt;采铜 - 思维运筹学导论（实践篇 · 组块化 · 下） - 开放的智力&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/learning-how-to-learn/home/week/2&quot;&gt;Coursera - Learning How to Learn Week 2&lt;/a&gt;&lt;/p&gt; </description><pubDate>Wed, 14 Dec 2016 00:00:00 +0000</pubDate><link>http://lijiawei.cc/posts/card-writing/</link><guid isPermaLink="true">http://lijiawei.cc/posts/card-writing/</guid> </item> <item><title>科技是如何劫持我们的？</title><description>&lt;ul id=&quot;markdown-toc&quot;&gt; &lt;li&gt;&lt;a href=&quot;#导言&quot; id=&quot;markdown-toc-导言&quot;&gt;导言&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#掌控选择&quot; id=&quot;markdown-toc-掌控选择&quot;&gt;掌控选择&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#成瘾设计&quot; id=&quot;markdown-toc-成瘾设计&quot;&gt;成瘾设计&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#无底洞&quot; id=&quot;markdown-toc-无底洞&quot;&gt;无底洞&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#走过路过不要错过&quot; id=&quot;markdown-toc-走过路过不要错过&quot;&gt;走过路过不要错过&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#社会认同&quot; id=&quot;markdown-toc-社会认同&quot;&gt;社会认同&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#礼尚往来&quot; id=&quot;markdown-toc-礼尚往来&quot;&gt;礼尚往来&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#立即打断&quot; id=&quot;markdown-toc-立即打断&quot;&gt;立即打断&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#捆绑需求&quot; id=&quot;markdown-toc-捆绑需求&quot;&gt;捆绑需求&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;导言&quot;&gt;导言&lt;/h2&gt; &lt;p&gt;当我们享受着科技给我们带来的种种好处时，科技是如何劫持我们的心智的？&lt;/p&gt; &lt;p&gt;参考资料如下：&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://sspai.com/35106&quot; title=&quot;科技如何劫持人们的心智：来自一位魔术师和谷歌的设计伦理学家&quot;&gt;科技如何劫持人们的心智：来自一位魔术师和谷歌的设计伦理学家&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://medium.com/swlh/how-technology-hijacks-peoples-minds-from-a-magician-and-google-s-design-ethicist-56d62ef5edf3#.cluvpbw46&quot; title=&quot;How Technology Hijacks People’s Minds — from a Magician and Google’s Design Ethicist&quot;&gt;How Technology Hijacks People’s Minds — from a Magician and Google’s Design Ethicist&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;掌控选择&quot;&gt;掌控选择&lt;/h2&gt; &lt;p&gt;科技经常让我们忽视不在屏幕上的选择。&lt;/p&gt; &lt;p&gt;当大众点评上列出了好评最高的10个餐厅时，好餐厅就只剩下10个了吗？&lt;/p&gt; &lt;p&gt;当豆瓣电影列出了「豆瓣电影250」的时候，世界上真的就只有250部好电影吗？&lt;/p&gt; &lt;p&gt;互联网可以帮助我们参考到许多信息，但互联网上参考到的信息其实并不等于我们生活中的所有信息。&lt;/p&gt; &lt;h2 id=&quot;成瘾设计&quot;&gt;成瘾设计&lt;/h2&gt; &lt;p&gt;随机性奖励会让人欲罢不能，这其实是多巴胺在起作用，多巴胺让人有获得奖励的欲望，当我们享受科技的好处时，我们期待下一次「刷新」也许就刷出了好玩的微博、知乎提问，下一次「射击」可以击杀，下一次「升级」可以抽到「高级装备」。这也就是所谓的「成瘾」，在不知情的情况想，被游戏性操控是个挺可悲的事情，因为你根本没有想过为什么自己停不下来。&lt;/p&gt; &lt;h2 id=&quot;无底洞&quot;&gt;无底洞&lt;/h2&gt; &lt;blockquote&gt; &lt;p&gt;康奈尔大学教授 Brian Wansink 通过他的研究证明，&lt;a href=&quot;http://foodpsychology.cornell.edu/discoveries/bottomless-bowls&quot;&gt;你可以用一个「无底碗」来诱骗人们在吃饭时不停地喝汤&lt;/a&gt;，在他们吃饭时这个「无底碗」会自动地被重新充满汤。有了这样的「无底碗」，人们会比用普通的碗多摄入 73% 的热量，同时他们对自己摄入热量的估计值会比实际值低 140 卡路里。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;读一本书你可以用厚度感知还有几页来控制自己要不要读完，但往往刷知乎、朋友圈的时候，你根本不知道自己什么时候会结束，于是，你便不停地刷刷刷，然后花了比你预想（或者根本没有预想）更多的时间。&lt;/p&gt; &lt;h2 id=&quot;走过路过不要错过&quot;&gt;走过路过不要错过&lt;/h2&gt; &lt;p&gt;就好像逛街的时候看到打折，总要进去看一看，我们有时会担心自己好像错过了什么，而科技的有些设定又放大了这层恐惧。&lt;/p&gt; &lt;p&gt;直播（包括竞技直播、主播直播），如果现在不看，以后就再也看不到了。&lt;/p&gt; &lt;p&gt;朋友圈，如果现在不刷，可能就错过一个热点话题。&lt;/p&gt; &lt;p&gt;微博、知乎、新闻，如果现在不看，可能就错过一个大新闻。&lt;/p&gt; &lt;p&gt;什么值得买，如果不赶紧刷一下，说不定某个打折就错过了。&lt;/p&gt; &lt;p&gt;其实，你想一想，相比你花的时间，你真的因为错过而彻底损失了什么吗？&lt;/p&gt; &lt;h2 id=&quot;社会认同&quot;&gt;社会认同&lt;/h2&gt; &lt;p&gt;我们希望有归属感、被别人赏识，所以我们精心地维护着自己的朋友圈，发自拍、发段子、发观点，给别人的朋友圈点赞，告诉别人我们可是好朋友啊（这就是点赞名单的唯一存在理由）。但你反过来想想，那些给你点赞的人就真的会在现实生活里玩得很好吗？事实上，哪怕你的好朋友们从来不给你点赞，你的朋友也还是你的朋友。&lt;/p&gt; &lt;h2 id=&quot;礼尚往来&quot;&gt;礼尚往来&lt;/h2&gt; &lt;p&gt;我给你点赞了，你也要给我点赞。我关注你了，你也要回关。&lt;/p&gt; &lt;h2 id=&quot;立即打断&quot;&gt;立即打断&lt;/h2&gt; &lt;p&gt;推送、通知都可能让你立即放下手里的活，没法保持专注，但其实，你早点晚点回复都一样。你完全可以关掉所有通知，紧急事件通常都没那么紧急。&lt;/p&gt; &lt;h2 id=&quot;捆绑需求&quot;&gt;捆绑需求&lt;/h2&gt; &lt;p&gt;微信难道不是个聊天工具吗？为什么我要看别人的朋友圈？为什么我要在微信里打游戏？&lt;/p&gt; &lt;p&gt;我就用豆瓣查个评分！为什么还有豆瓣广播？&lt;/p&gt; &lt;p&gt;我用知乎就是看点和自己有关的干货的！关注人的时间线和我有毛关系？&lt;/p&gt; &lt;p&gt;淘宝难道不就是让我买我已经想好买的东西吗？为什么还有发现功能？&lt;/p&gt; &lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;关闭通知。&lt;/li&gt; &lt;li&gt;在固定时间刷微博、朋友圈，不要想到就去刷。&lt;/li&gt; &lt;li&gt;打开应用、网页前，要有一个明确的目的。&lt;/li&gt; &lt;li&gt;控制时间。&lt;/li&gt; &lt;/ul&gt; </description><pubDate>Tue, 23 Aug 2016 17:50:00 +0100</pubDate><link>http://lijiawei.cc/posts/how-tech-kill-us/</link><guid isPermaLink="true">http://lijiawei.cc/posts/how-tech-kill-us/</guid> </item> </channel> </rss>
